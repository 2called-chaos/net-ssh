<h1>Net::SSH</h1>

<p>This quick-reference provides a brief overview of the Net::SSH API. It is not an exhaustive reference, including only those methods and options that will be most frequently used. Please refer to the <a href="api/index.html">API documentation</a> for a complete API reference.</p>

<h2>Net::SSH</h2>

<h3><code>::start(host, user, options={}, &block)</code></h3>

<p>This will start up a new SSH connection to the given host, as the given user. If a block is given, the connection will be yielded to it and then closed when the block finishes, otherwise the connection will be returned. Some of the available options are:</p>

<ul>
  <li><code>:compression</code>: the compression algorithm to use, or +true+ to use whatever is supported.</li>
  <li><code>:compression_level</code>: the compression level to use when sending data (1 for best speed, 9 for best compression).</li>
  <li><code>:forward_agent<li>: set to true if you want the SSH agent connection to be forwarded</li>
  <li><code>:keys</code>: an array of file names of private keys to use for publickey and hostbased authentication</li>
  <li><code>:paranoid</code>: either true, false, or :very, specifying how strict host-key verification should be</li>
  <li><code>:password</code>: the password to use to login</li>
  <li><code>:port</code>: the port to use when connecting to the reote host</li>
  <li><code>:proxy</code>: a proxy instance to use when connecting</li>
  <li><code>:timeout</code>: how long to wait for the initial connection to be made</li>
  <li><code>:verbose</code>: how verbose to be (0 is very verbose, 4 is not very verbose)</li>
</ul>


<h2>Connection (Net::SSH::Connection::Session)</h2>

<h3><code>#exec(command, &block)</code></h3>

<p>Queues the command for execution and returns immediately. Requires an event loop (see <code>#loop</code> or <code>#process</code>) in order for the command to actually be executed. If a block is given, output is yielded to the block (three parameters, channel, type, and data). Otherwise, output is written to the terminal.</p>

<h3><code>#exec!(command, &block)</code></h3>

<p>Same as <code>#exec</code>, except this will block until the command finishes. If no block is given, the output will be returned as a string, rather than be written to the terminal</p>

<h3><code>#forward</code></h3>

<p>Returns the forwarding service, which can be used to forward ports.</p>

<h3><code>#loop(wait=nil, &block)</code></h3>

<p>Runs the event loop until some condition is met. The <code>wait</code> parameter will be passed directly to <code>#process</code>. If a block is given, it should return false when the event loop should exit. If a block is not given, the loop will continue until there are no more open channels.</p>

<h3><code>#open_channel(type="session", *extra, &block)</code></h3>

<p>Queues a channel open request and returns the new (as-yet unopened) channel object. When the server responds that the channel has been opened, the block will be invoked and the channel object passed to it.</p>

<h3><code>#process(wait=nil, &block)</code></h3>

<p>Runs a single iteration of the event loop. If <code>wait</code> is nil, this will block until activity arrives from the server. Otherwise, <code>wait</code> must be a number indicating how many seconds to wait for activity before returning. The block, if present, should return false if the method should exit before querying the server (but after processing open channels).</p>


<h2>Channel (Net::SSH::Connection::Channel)</h2>

<h3><code>#[](name)</code></h3>

<p>Returns the value of the custom property with the given name (or nil if no such property exists.</p>

<h3><code>#[]=(name, value)</code></h3>

<p>Sets a custom property on the channel.</p>

<h3><code>#close</code></h3>

<p>Causes the channel to close.</p>

<h3><code>#exec(command, &block)</code></h3>

<p>Sends a channel request to the server, requesting that the given command be executed. Returns immediately. If a block is given, it will be called before any output is sent from the command, with two parameters: channel, and a boolean value indicating success or failure (where success means the server was able to try and execute the command, even if the command failed).</p>

<h3><code>#on_close(&block)</code></h3>

<p>Registers a callback to be invoked when the server closes the channel. The block takes a single argument: the channel itself.</p>

<h3><code>#on_data(&block)</code></h3>

<p>Registers a callback, to be invoked when data arrives for the channel. The block takes two arguments: the channel, and the data.</p>

<h3><code>#on_extended_data(&block)</code></h3>

<p>Registers a callback, to be invoked when extended data (typically stderr) arrives for the channel. The block takes three arguments: the channel, the data type (almost always 1), and the data.</p>

<h3><code>#on_process(&block)</code></h3>

<p>Registers a callback to be invoked on every iteration of the event loop. The block takes a single argument, the channel itself.</p>

<h3><code>#on_request(type, &block)</code></h3>

<p>Registers a callback to be invoked when a channel request of the given type is received. Some types you can listen for are "exit-status" and "exit-signal". The block takes two arguments: the channel, and a packet object containing additional, request-specific data.</p>

<h3><code>#request_pty(options={}, &block)</code></h3>

<p>Requests that a pseudo-tty be allocated for the channel. This ought to be executed before any commands. If a block is given, it will be called as soon as the pty is allocated, with two parameters: channel, and a boolean value indicating success or failure of the operation. The options hash may contain the following keys:</p>

<ul>
  <li><code>:term</code>: the terminal type to use (defaults to "xterm")</li>
  <li><code>:chars_wide</code>: how many characters wide the terminal is (defaults to 80)</li>
  <li><code>:chars_high</code>: how many characters high the terminal is (defaults to 24)</li>
  <li><code>:pixels_wide</code>: how many pixels wide the terminal is (defaults to 640)</li>
  <li><code>:pixels_high</code>: how many pixels high the terminal is (defaults to 480)</li>
  <li><code>:modes</code>: a hash of mode mappings to define for the terminal</li>
</ul>

<h3><code>#send_data(data)</code></h3>

<p>Enqueues the given data, to be sent at the next available opportunity over the channel. For a remote process, this data arrives on standard input (stdin). For other channel types, the data will be interpreted differently.</p>


<h2>Forward (Net::SSH::Service::Forward)</h2>

<h3><code>local(bind_address="127.0.0.1", local_port, host, port)</code></h3>

<p>Initiates a forwarded port, from the given local port, to the host and port indicated, via the SSH connection. The bind address is optional, and if omitted defaults to 127.0.0.1. In order for the port to be actively forwarding data, the SSH event loop must be running.</p>

<h3><code>remote(port, host, remote_port, bind_address="127.0.0.1")</code></h3>

<p>Initiates a forwarded port, from the <code>remote_port</code> on the remote end of the SSH connection, to the given host and port. The bind address is optional and defaults to "127.0.0.1". In order for the port to be actively forwarding data, the SSH event loop must be running.</p>
