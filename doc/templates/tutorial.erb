<h1>Net::SSH Tutorial</h1>

<h2>Getting Started</h2>

<p>To get started, make sure that you've got Net::SSH installed. Check out the <a href="install.html">installation instructions</a>.</p>

<p>Also, make sure that you have a server handy that you can connect to via SSH. It'll be best if you've got it set up to connect via a public key, and have an SSH agent running locally, but if not, you can use a password to log in, too.</p>

<p>This tutorial will walk you through some of the basics of Net::SSH, but certainly won't try to cover everything. Feel free to experiment on your own as we go through this.</p>

<h2>The Simplest Possible Program</h2>

<p>Let's start with a simple program that executes a command on the remote host. For this tutorial, I'm going to call that remote host "example.com", but you'll want to replace that with your own remote host name. Also, the username I'm using in this tutorial is "bob"; be sure to replace that with your own username.</p>

<h:code lang="ruby">
require 'net/ssh'

Net::SSH.start("example.com", "bob") do |ssh|
  puts ssh.exec!("echo hello world")
end
</h:code>

<p>If you don't have a public key configured to use for logging in, you may need to add <code>:password => "whatever"</code> to the end of the argument list of the <code>#start</code> method.</p>

<p>Running the above program, you should see "hello world" appear, as if my magic, on your terminal screen! This isn't your average hello world, though. This is one that was echoed on the remote host via SSH.</p>

<p>Let's dissect that a bit. First, we used <code>Net::SSH.start</code> to establish the connection to our server. When the connection was made and completely initialized, the new session object was yielded to the block. (We called the variable <code>ssh</code> here, but you can naturally call it whatever you want.)</p>

<p>Then, we called the <code>#exec!</code> method on the session, which takes a command to execute, and returns the output as a string. When the block finished, the connection was automatically cleaned up and closed for us.</p>

<h2>Parallel Execution</h2>

<p>Next, let's look at how we can make Net::SSH run two commands in parallel.</p>

<h:code lang="ruby">
require 'net/ssh'

Net::SSH.start("example.com", "bob") do |ssh|
  ssh.exec "hostname"
  ssh.exec "uptime"
  ssh.loop
end
</h:code>

<p>This program will show the name of the host, and the uptime report. Note that this time, we used <code>exec</code> (without the bang), rather than <code>exec!</code> (with the bang). The difference is that <code>exec</code> will return immediately, after simply queueing the request, while <code>exec!</code> will block until the command actually completes. Since <code>exec</code> doesn't actually wait for the command to run, we need to use <code>ssh.loop</code> to force the event loop to run. It will do so until both commands complete, and will then return.</p>

<p>While <code>exec!</code> returned the output, <code>exec</code> cannot, since it returns before the command completes. Instead, <code>exec</code> simply writes the output to your terminal.</p>

<h2>Using a Callback to Capture Output</h2>

<p>Now, we're going to get kind of tricky. Let's say we wanted to capture the output from those two commands, but still run them in parallel. Well, if we give a block to each of those commands, Net::SSH will pass all data received to the block, instead of printing it.</p>

<h:code lang="ruby">
require 'net/ssh'

Net::SSH.start("example.com", "bob") do |ssh|
  hostname = ""
  uptime   = ""

  ssh.exec("hostname") { |channel, type, data| hostname << data }
  ssh.exec("uptime")   { |channel, type, data| uptime << data }
  ssh.loop

  puts "hostname: #{hostname.inspect}"
  puts "uptime:   #{uptime.inspect}"
end
</h:code>

<p>Note the block given to the <code>#exec</code> method accepts three parameters: <code>channel</code>, <code>type</code> and <code>data</code>. The channel parameter is the underlying channel abstraction that the command is being executed by. We won't do anything with that right now, but it will come in handy later. The type parameter says whether the data is coming over on standard output (<code>:stdout</code>) or standard error (<code>:stderr</code>). We don't care about it for this example, but you might in other situations. The last parameter is the actual data.</p>

<p>Every time the remote command emits output, that output gets routed to the  corresponding block for the command. In this way, you can aggregate data quite easily, and even expect-like programs that respond to certain patterns of output.</p>

<h2>Using Channel Properties to Store Channel State</h2>

<p>In that last example, we actually used local variables to collect the output from the channels, but that was kind of clunky because we had to initialize them outside the blocks first. This example will demonstrate using custom channel properties to collect the output.</p>

<h:code lang="ruby">
require 'net/ssh'

Net::SSH.start("example.com", "bob") do |ssh|
  hostname = ssh.exec("hostname") { |ch, type, data| (ch[:out] ||= "") << data }
  uptime   = ssh.exec("uptime")   { |ch, type, data| (ch[:out] ||= "") << data }
  ssh.loop

  puts "hostname: #{hostname[:out].inspect}"
  puts "uptime:   #{uptime[:out].inspect}"
end
</h:code>

<p>That's a bit more concise, though some might call the inline initialize-and-append part too clever. All we do is first make sure <code>ch[:out]</code> is initialized to the empty string, and then we append the data to that. Note that even though <code>#exec</code> returns immediately, it does return a reference to the nascent channel object, which we can use later to pull custom properties out of.</p>

<p>You'll find custom channel properties to be very, very useful. The channel acts much like a hash, letting you store named values in it, which you can get at any time you have a reference to the channel. Then, every channel callback always yields a reference to the channel itself, which makes it a very handy and light-weight way to manage per-channel state.</p>

<h2>Capturing Exit Status</h2>

<p>Now, one of the limitations of the built-in (but every-so-handy) <code>Session#exec</code> and <code>Session#exec!</code> methods, is that they cannot do everything that a channel is capable of doing. For instance, what if you want to know whether a command succeeds or not? SSH does provide a way to capture the exit-status of a command, but that functionality isn't exposed by <code>Session#exec</code>.</p>

<p>Here's where we have to go bare metal and play directly with channels (which is not as hazardous as it sounds!). We open the channel, request that the command be executed, and then register the various callbacks that we need.</p>

<h:code lang="ruby">
require 'net/ssh'

Net::SSH.start("example.com", "bob") do |ssh|
  hostname = ssh.open_channel do |channel|
    channel.exec "hostname"
    channel[:out] = ""

    channel.on_data { |ch, data| ch[:out] << data }
    channel.on_extended_data { |ch, type, data| ch[:out] << data }

    channel.on_request("exit-status") do |ch, request|
      status = request.read_long
      raise "command failed with #{status}" unless status == 0
    end
  end

  ssh.loop

  puts "hostname: #{hostname[:out].inspect}"
end
</h:code>

<p>So, first, we tell the session that we want to open a new channel, by calling <code>#open_channel</code>. This will immediately return the new channel object, but the server has not yet actually opened the channel! Instead, when the server opens the channel, the block that we passed to <code>#open_channel</code> will be called, and the channel object will be yielded to it. (Most times, you'll just throw away the returned channel object from <code>#open_channel</code>; we're only holding onto it because we want to reference the channel state later.)</p>

<p>Once the channel has been opened, we queue up the <code>#exec</code> request, initialize our custom <code>:out</code> property, and add some callbacks.</p>

<p>The <code>#on_data</code> callback gets invoked when the server sends data on standard output. We just append the data to the output.</p>

<p>The <code>#on_extended_data</code> callback gets invoked when the server sends "extended" data (like standard error). Again, we'll just append it to the output (though you might prefer to append it to a different state value, like <code>:err</code> or something).</p>

<p>Lastly, the <code>#on_request</code> callback gets invoked when a channel request of the given type is received from the server. In this case, we have to do a bit of work to pull the actual status from the packet given us by the server: we just read the next 4-byte integer from the packet (via <code>#read_long</code>), and that's the status code. You could do whatever you wanted with it (like stuff it in a channel property), but we're just going to raise an exception if the status was non-zero.</p>

<h2>Encapsulating an SSH State Machine</h2>

<p>The above works great, but it's fairly verbose, and it would be something of a pain to have to do that <em>every time</em> we wanted to execute a command. This is where it comes in handy to encapsulate an SSH state machine (which is what we've created with all of those callbacks). There are two basic ways to do this.</p>

<p>The first is to create a method that sets everything up for you. This works really well for smaller state machines:</p>

<h:code lang="ruby">
require 'net/ssh'

def exec_with_status(ssh, command)
  ssh.open_channel do |channel|
    channel.exec(command)
    channel[:out] = ""

    channel.on_data { |ch, data| ch[:out] << data }
    channel.on_extended_data { |ch, type, data| ch[:out] << data }

    channel.on_request("exit-status") do |ch, request|
      status = request.read_long
      raise "`#{command}' failed with #{status}" unless status == 0
    end
  end
end

Net::SSH.start("example.com", "bob") do |ssh|
  hostname = exec_with_status(ssh, "hostname")
  uptime   = exec_with_status(ssh, "uptime")

  ssh.loop

  puts "hostname: #{hostname[:out].inspect}"
  puts "uptime:   #{uptime[:out].inspect}"
end
</h:code>

<p>The other way (which is actually overkill for this small example) is to create a class, and have each callback delegate to one of the methods of the class:</p>

<h:code lang="ruby">
require 'net/ssh'

class ExecWithStatus
  def initialize(ssh, command)
    @command = command
    @channel = ssh.open_channel(&method(:channel_opened))
    @channel[:out] = ""
  end

  def result
    @channel[:out]
  end

  private

    def channel_opened(channel)
      channel.exec(@command)
      channel.on_data(&method(:channel_data))
      channel.on_extended_data(&method(:channel_extended_data))
      channel.on_request("exit-status", &method(:exit_status))
    end

    def channel_data(channel, data)
      channel[:out] << data
    end

    def channel_extended_data(channel, type, data)
      channel[:out] << data
    end

    def exit_status(channel, request)
      status = request.read_long
      raise "`#{@command}' failed with #{status}" unless status == 0
    end
end

Net::SSH.start("example.com", "bob") do |ssh|
  hostname = ExecWithStatus.new(ssh, "hostname")
  uptime   = ExecWithStatus.new(ssh, "uptime")

  ssh.loop

  puts "hostname: #{hostname.result.inspect}"
  puts "uptime:   #{uptime.result.inspect}"
end
</h:code>

<p>One of the benefits of that second approach is that it lends itself really well to reopening the session class and adding a new helper:</p>

<h:code lang="ruby">
require 'net/ssh'

class ExecWithStatus
  # ...
end

class Net::SSH::Connection::Session
  def exec_with_status(command)
    ExecWithStatus.new(self, command)
  end
end

Net::SSH.start("example.com", "bob") do |ssh|
  hostname = ssh.exec_with_status("hostname")
  uptime   = ssh.exec_with_status("uptime")

  ssh.loop

  puts "hostname: #{hostname.result.inspect}"
  puts "uptime:   #{uptime.result.inspect}"
end
</h:code>

<p>You can look at the source code for Net::SCP and Net::SFTP for examples of the latter, class-based SSH state-machine. For smaller state machines, though, a simple wrapper method works fine.</p>