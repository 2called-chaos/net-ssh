Executing commands is at the heart of what Net::SSH is all about. The simplest way to do it is to open an SSH connection, and then call "exec!" (_with_ the bang):

<h:code lang="ruby">
require 'net/ssh'

Net::SSH.start("host.com", "bob") do |ssh|
  puts ssh.exec!("echo hello")
end
</h:code>

The @exec!@ method, by default, will return the output from the command, as a string. If the command emitted data to both stdout and stderr, the resulting string will include both all muddled together.

So, what if you want to differentiate between the two? Well, you can pass a block to @exec!@. Each time data is received from the command, the block is invoked with three parameters: the _channel_ object (which represents the virtual SSH channel that is processing the command), the _type_ of the data (a symbol, either @:stdout@ or @:stderr@), and the data itself (as a string):

<h:code lang="ruby">
require 'net/ssh'

Net::SSH.start("host.com", "bob") do |ssh|
  ssh.exec!("echo hello") do |channel, type, data|
    if type == :stdout
      puts(data)
    else
      puts "Agh! We got stderr output!"
      puts data
    end
  end
end
</h:code>

Note that @exec!@ will _block_ (it will not return) until the command completes. This means you can only process a single command at a time (which is, admittedly, sufficient for most uses). If that is ever _not_ what you want, you can use @exec@ (without the exclamation mark):

<h:code lang="ruby">
require 'net/ssh'

Net::SSH.start("host.com", "bob") do |ssh|
  ssh.exec "echo hello"
  ssh.loop
end
</h:code>

The @exec@ method does _not_ block; it returns immediately, and won't actually be processed until the SSH _event loop_ runs. (See the "Net::SSH overview":../overview.html for more information about the event loop.) Thus, you need to call the @#loop@ method at some point to run the command.

This technique lets you "queue up" several commands to execute, and fire them all off at once:

<h:code lang="ruby">
require 'net/ssh'

Net::SSH.start("host.com", "bob") do |ssh|
  ssh.exec "date && uptime"
  ssh.exec "mysqldump > /tmp/backup.sql"
  ssh.exec "ruby ~/maintenance.rb"
  ssh.loop
end
</h:code>

By default, @exec@ will print all :stdout data to @$stdout@, and all :stderr data to @$stderr@. However, you can pass a block to it, just like for @exec!@, to have finer control over what happens with the data:

<h:code lang="ruby">
require 'net/ssh'

Net::SSH.start("host.com", "bob") do |ssh|
  ssh.exec "echo hello" do |channel, type, data|
    # ...
  end

  ssh.loop
end
</h:code>