If all you want to do is execute a command and capture it's output to a variable, your task is boringly simple:

<h:code lang="ruby">
require 'net/ssh'

Net::SSH.start("host.com", "bob") do |ssh|
  output = ssh.exec!("ls -l /usr/lib")
  puts "result:"
  puts output
end
</h:code>

If you need to capture output in an asynchronous fashion, though, you might need to do a bit more work:

<h:code lang="ruby">
require 'net/ssh'

Net::SSH.start("host.com", "bob") do |ssh|
  channel = ssh.exec("ls -l /usr/lib") do |ch, type, data|
    ch[:result] ||= ""
    ch[:result] << data
  end

  ssh.loop { !channel[:closed] }

  puts "result:"
  puts channel[:result]
end
</h:code>

Or, you can do the job in longhand by using channels directly:

<h:code lang="ruby">
require 'net/ssh'

Net::SSH.start("host.com", "bob") do |ssh|
  channel = ssh.open_channel do |channel|
    channel.exec "ls -l /usr/lib"

    channel.on_data do |ch, data|
      ch[:result] ||= ""
      ch[:result] << data
    end

    channel.on_extended_data do |ch, data|
      ch[:result] ||= ""
      ch[:result] << data
    end

    channel.on_close do |ch|
      ch[:closed] = true
    end
  end

  ssh.loop { !channel[:closed] }

  puts "result:"
  puts channel[:output]
end
</h:code>

Naturally, you're probably wondering why you would _ever_ want to do it longhand... the answer, dear reader, is that you usually won't. However, if you are using Net::SSH in an interactive environment (like, fronting it with a GUI or something similar), you may need to have finer-grained control over different aspects of executing the command. Also, some features (like requesting pseudo-tty's and testing for exit status) are not available for use with the simpler @#exec@ methods.